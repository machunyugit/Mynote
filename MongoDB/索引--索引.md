## 积硅步, 致千里

### 概要

1. 索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。
2. 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。
3. 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构

### 测试

1. 测试没加索引的性能

   ```javascript
   //准备数据
       for (var i = 0; i < 20000;i++) {
           db.books.insert({number:i,name:i+"book"});
       }
   //计算查询需要的时间
       var start = new Date();
       db.books.find({number:165871});
       var end = new Date();
       end - start   //150
   
   for(i=0;i<100000;i++){
       db.users.insert({
           "_id":i,
           "username":"user"+i, 
           "age":Math.floor(Math.random()*120), 
       	"created":new Date()});
   }
   ```

2. 索引的使用需要注意的地方

   - 创建索引的时候注意 1 是正序创建索引 -1 是倒序创建索引

   - 索引的创建在提高查询性能的同时会影响插入的性能

     对于经常查询少插入的文档可以考虑用索引

   - 复合索引要注意索引的先后顺序

   - 在做排序查询的时候也可以加上索引

### 创建索引

| Parameter  | Type     | Description                                                  |
| ---------- | -------- | ------------------------------------------------------------ |
| background | Boolean  | 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 "background" 可选参数。 "background" 默认值为**false**。 |
| unique     | Boolean  | 建立的索引是否唯一。指定为true创建唯一索引。默认值为**false**. |
| name       | string   | 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 |
| dropDups   | Boolean  | 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 **false**. |
| sparse     | Boolean  | 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 **false**. |
| weights    | document | 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重 |



### 单个字段上的索引

```javascript
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
```

1. 在单个字段上创建升序索引 

   * 创建索引

     ```javascript
     //创建正序的索引
     db.records.createIndex({score:1},{name:"scoreAscIndex"})
     //创建倒序的索引
     db.records.createIndex({score:-1},{name:"scoreDescIndex"})
     ```

   * 下面的查询可以用到这个索引

     ```javascript
     db.records.find( { score: 2 } )
     db.records.find( { score: { $gt: 10 } } )
     ```

   * 查询计划

     ```html
     > db.records.find( { score: { $gt: 10 } } ).explain();
     {
             "queryPlanner" : {
                     "plannerVersion" : 1,
                     "namespace" : "user.records",
                     "indexFilterSet" : false,
                     "parsedQuery" : {
                             "score" : {
                                     "$gt" : 10
                             }
                     },
                     "winningPlan" : {
                             "stage" : "FETCH",
                             "inputStage" : {
                                     "stage" : "IXSCAN",
                                     "keyPattern" : {
                                             "score" : 1
                                     },
                                     "indexName" : "scoreAscIndex",
                                     "isMultiKey" : false,
                                     "isUnique" : false,
                                     "isSparse" : false,
                                     "isPartial" : false,
                                     "indexVersion" : 2,
                                     "direction" : "forward",
                                     "indexBounds" : {
                                             "score" : [
                                                     "(10.0, inf.0]"
                                             ]
                                     }
                             }
                     },
                     "rejectedPlans" : [ ]
             },
             "serverInfo" : {
                     "host" : "PC-20170330JXUR",
                     "port" : 27017,
                     "version" : "3.6.5",
                     "gitVersion" : "a20ecd3e3a174162052ff99913bc2ca9a839d618"
             },
             "ok" : 1
     }
     ```

2. 在嵌入的文档中建立索引

   * 创建索引

     ```javascript
     //通过 . 的这种操作对嵌入的文档建立索引
     db.records.createIndex( { "location.state": 1 },{name:"stateIndex"} )
     ```

   * 下面的查询可以用到这个索引

     ```javascript
     db.records.find( { "location.state": "CA" } )
     db.records.find( { "location.city": "Albany", "location.state": "NY" } )
     ```

   * 查询计划

     ```html
     > db.records.find( { "location.city": "Albany", "location.state": "NY" } ).explain();
     {
             "queryPlanner" : {
                     "plannerVersion" : 1,
                     "namespace" : "user.records",
                     "indexFilterSet" : false,
                     "parsedQuery" : {
                             "$and" : [
                                     {
                                             "location.city" : {
                                                     "$eq" : "Albany"
                                             }
                                     },
                                     {
                                             "location.state" : {
                                                     "$eq" : "NY"
                                             }
                                     }
                             ]
                     },
                     "winningPlan" : {
                             "stage" : "FETCH",
                             "filter" : {
                                     "location.city" : {
                                             "$eq" : "Albany"
                                     }
                             },
                             "inputStage" : {
                                     "stage" : "IXSCAN",
                                     "keyPattern" : {
                                             "location.state" : 1
                                     },
                                     "indexName" : "stateIndex",
                                     "isMultiKey" : false,
                                     "isUnique" : false,
                                     "isSparse" : false,
                                     "isPartial" : false,
                                     "indexVersion" : 2,
                                     "direction" : "forward",
                                     "indexBounds" : {
                                             "location.state" : [
                                                     "[\"NY\", \"NY\"]"
                                             ]
                                     }
                             }
                     },
                     "rejectedPlans" : [ ]
             },
             "serverInfo" : {
                     "host" : "PC-20170330JXUR",
                     "port" : 27017,
                     "version" : "3.6.5",
                     "gitVersion" : "a20ecd3e3a174162052ff99913bc2ca9a839d618"
             },
             "ok" : 1
     }
     ```

### 复合索引

1. 语法

   ```html
   db.collection.createIndex( { <field1>: <type>, <field2>: <type2>, ... } )
       
   db.collection.createIndex({"title":1,"description":-1},{name:"title_desc"})
   ```

2. 排序

   索引以升序（`1`）或降序（`-1`）排序顺序存储对字段的引用。对于单字段索引，键的排序顺序无关紧要，因为MongoDB可以在任一方向上遍历索引。但是，对于复合索引，排序顺序对于确定索引是否可以支持排序操作很重要。 

3. 只有基于多个查询条件进行排序时，索引方向才是比较重要的。如果只是基于单一键进行排序，MongoDB可以简单地从相反方向读取索引。

4. 使用覆盖索引

   为了确保查询只是用索引就可以完成，应该使用投射来制定不要返回 “_id” 字段 ( 除非它是索引的一部分)。可能需要对不需要查询的字段做索引。

### 强制指定 使用那个索引

```javascript
db.books.find({"name":"0book"}).hint(name:-1);
```

### 索引的类型

1. 唯一索引

   ```html
   db.collection.createIndex({"number":1},{"unique":true});
   ```

   __如果一个文档没有对应的键, 索引会将其作为null的存储. 所以, 如果对某个键建立了唯一索引, 但插入了多个缺少该索引键的文档,    由于集合中已经存在一个该索引键的值为null的文档而导致插入失败.__

2. 稀疏索引

   * 稀疏索引仅包含具有索引字段的文档的条目，即使索引字段包含空值也是如此。索引会跳过缺少索引字段的任何文档。索引是“稀疏的”，因为它不包含集合的所有文档。 

   * 唯一索引会把null看做值, 所以无法 将多个缺少唯一索引中的键的文档插入到集合中. 然而, 在有些情况下, 可能希望唯一索引值对包含相应键的文档生效. 这时可以将 unique 和 sparse 选项组合在一起使用

     ```html
     db.users.createIndex({"email":1},{unqiue:true},{sparse:true});
     ```

### 索引管理

1. 查看某给集合都使用了那些索引

   ```html
   db.users.getIndexes();
   ```

2. 查看索引是否创建成功

   ```html
   db.getLastError();
   ```

3. 新建索引是一件既费时又浪费资源的事情, 默认情况下, MongoDB会尽可能快地创建索引, 阻塞所有对数据库的读请求和写请求, 一直到索引创建完成. 如果希望数据库在创建索引的同时仍然能够处理 读写请求, 可以在创建索引时指定 `background` 选项. 这样在创建索引时, 如果有新的数据库请求需要处理, 创建索引的过程就会暂停一下, 但仍然会对应用程序影响较大.

### 参考网址

1. 创建空间位置索引 `https://blog.csdn.net/zhangzhebjut/article/details/23021073` 





