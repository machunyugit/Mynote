## 积硅步, 致千里

### 概要

1. 索引通常能够极大的提高查询的效率，如果没有索引，MongoDB在读取数据时必须扫描集合中的每个文件并选取那些符合查询条件的记录。
2. 这种扫描全集合的查询效率是非常低的，特别在处理大量的数据时，查询可以要花费几十秒甚至几分钟，这对网站的性能是非常致命的。
3. 索引是特殊的数据结构，索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构

### 测试

1. 测试没加索引的性能

   ```javascript
   //准备数据
       for (var i = 0; i < 20000;i++) {
           db.books.insert({number:i,name:i+"book"});
       }
   //计算查询需要的时间
       var start = new Date();
       db.books.find({number:165871});
       var end = new Date();
       end - start   //150
   
   for(i=0;i<100000;i++){
       db.users.insert({
           "_id":i,
           "username":"user"+i, 
           "age":Math.floor(Math.random()*120), 
       	"created":new Date()});
   }
   ```

2. 索引的使用需要注意的地方

   - 创建索引的时候注意 1 是正序创建索引 -1 是倒序创建索引

   - 索引的创建在提高查询性能的同时会影响插入的性能

     对于经常查询少插入的文档可以考虑用索引

   - 复合索引要注意索引的先后顺序

   - 在做排序查询的时候也可以加上索引

### 创建索引

| Parameter  | Type     | Description                                                  |
| ---------- | -------- | ------------------------------------------------------------ |
| background | Boolean  | 建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 "background" 可选参数。 "background" 默认值为**false**。 |
| unique     | Boolean  | 建立的索引是否唯一。指定为true创建唯一索引。默认值为**false**. |
| name       | string   | 索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。 |
| dropDups   | Boolean  | 在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 **false**. |
| sparse     | Boolean  | 对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 **false**. |
| weights    | document | 索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重 |



### 单个字段上的索引

```javascript
{
  "_id": ObjectId("570c04a4ad233577f97dc459"),
  "score": 1034,
  "location": { state: "NY", city: "New York" }
}
```

1. 在单个字段上创建升序索引 

   * 创建索引

     ```javascript
     //创建正序的索引
     db.records.createIndex({score:1},{name:"scoreAscIndex"})
     //创建倒序的索引
     db.records.createIndex({score:-1},{name:"scoreDescIndex"})
     ```

   * 下面的查询可以用到这个索引

     ```javascript
     db.records.find( { score: 2 } )
     db.records.find( { score: { $gt: 10 } } )
     ```

   * 查询计划

     ```html
     > db.records.find( { score: { $gt: 10 } } ).explain();
     {
             "queryPlanner" : {
                     "plannerVersion" : 1,
                     "namespace" : "user.records",
                     "indexFilterSet" : false,
                     "parsedQuery" : {
                             "score" : {
                                     "$gt" : 10
                             }
                     },
                     "winningPlan" : {
                             "stage" : "FETCH",
                             "inputStage" : {
                                     "stage" : "IXSCAN",
                                     "keyPattern" : {
                                             "score" : 1
                                     },
                                     "indexName" : "scoreAscIndex",
                                     "isMultiKey" : false,
                                     "isUnique" : false,
                                     "isSparse" : false,
                                     "isPartial" : false,
                                     "indexVersion" : 2,
                                     "direction" : "forward",
                                     "indexBounds" : {
                                             "score" : [
                                                     "(10.0, inf.0]"
                                             ]
                                     }
                             }
                     },
                     "rejectedPlans" : [ ]
             },
             "serverInfo" : {
                     "host" : "PC-20170330JXUR",
                     "port" : 27017,
                     "version" : "3.6.5",
                     "gitVersion" : "a20ecd3e3a174162052ff99913bc2ca9a839d618"
             },
             "ok" : 1
     }
     ```

2. 在嵌入的文档中建立索引

   * 创建索引

     ```javascript
     //通过 . 的这种操作对嵌入的文档建立索引
     db.records.createIndex( { "location.state": 1 },{name:"stateIndex"} )
     ```

   * 下面的查询可以用到这个索引

     ```javascript
     db.records.find( { "location.state": "CA" } )
     db.records.find( { "location.city": "Albany", "location.state": "NY" } )
     ```

   * 查询计划

     ```html
     > db.records.find( { "location.city": "Albany", "location.state": "NY" } ).explain();
     {
             "queryPlanner" : {
                     "plannerVersion" : 1,
                     "namespace" : "user.records",
                     "indexFilterSet" : false,
                     "parsedQuery" : {
                             "$and" : [
                                     {
                                             "location.city" : {
                                                     "$eq" : "Albany"
                                             }
                                     },
                                     {
                                             "location.state" : {
                                                     "$eq" : "NY"
                                             }
                                     }
                             ]
                     },
                     "winningPlan" : {
                             "stage" : "FETCH",
                             "filter" : {
                                     "location.city" : {
                                             "$eq" : "Albany"
                                     }
                             },
                             "inputStage" : {
                                     "stage" : "IXSCAN",
                                     "keyPattern" : {
                                             "location.state" : 1
                                     },
                                     "indexName" : "stateIndex",
                                     "isMultiKey" : false,
                                     "isUnique" : false,
                                     "isSparse" : false,
                                     "isPartial" : false,
                                     "indexVersion" : 2,
                                     "direction" : "forward",
                                     "indexBounds" : {
                                             "location.state" : [
                                                     "[\"NY\", \"NY\"]"
                                             ]
                                     }
                             }
                     },
                     "rejectedPlans" : [ ]
             },
             "serverInfo" : {
                     "host" : "PC-20170330JXUR",
                     "port" : 27017,
                     "version" : "3.6.5",
                     "gitVersion" : "a20ecd3e3a174162052ff99913bc2ca9a839d618"
             },
             "ok" : 1
     }
     ```

### 复合索引

1. 语法

   ```html
   db.collection.createIndex( { <field1>: <type>, <field2>: <type2>, ... } )
       
   db.collection.createIndex({"title":1,"description":-1},{name:"title_desc"})
   ```

2. 排序

   索引以升序（`1`）或降序（`-1`）排序顺序存储对字段的引用。对于单字段索引，键的排序顺序无关紧要，因为MongoDB可以在任一方向上遍历索引。但是，对于复合索引，排序顺序对于确定索引是否可以支持排序操作很重要。 

3. 只有基于多个查询条件进行排序时，索引方向才是比较重要的。如果只是基于单一键进行排序，MongoDB可以简单地从相反方向读取索引。

4. 使用覆盖索引

   为了确保查询只是用索引就可以完成，应该使用投射来制定不要返回 “_id” 字段 ( 除非它是索引的一部分)。可能需要对不需要查询的字段做索引。

### 强制指定 使用那个索引

```javascript
db.books.find({"name":"0book"}).hint(name:-1);
```

### 索引的类型

1. 唯一索引

   ```html
   db.collection.createIndex({"number":1},{"unique":true});
   ```

   __如果一个文档没有对应的键, 索引会将其作为null的存储. 所以, 如果对某个键建立了唯一索引, 但插入了多个缺少该索引键的文档,    由于集合中已经存在一个该索引键的值为null的文档而导致插入失败.__

2. 稀疏索引

   * 稀疏索引仅包含具有索引字段的文档的条目，即使索引字段包含空值也是如此。索引会跳过缺少索引字段的任何文档。索引是“稀疏的”，因为它不包含集合的所有文档。 

   * 唯一索引会把null看做值, 所以无法 将多个缺少唯一索引中的键的文档插入到集合中. 然而, 在有些情况下, 可能希望唯一索引值对包含相应键的文档生效. 这时可以将 unique 和 sparse 选项组合在一起使用

     ```html
     db.users.createIndex({"email":1},{unqiue:true},{sparse:true});
     ```

### 索引管理

网址 : `https://docs.mongodb.com/manual/tutorial/manage-indexes/`

1. 查看某给集合都使用了那些索引

   ```html
   db.users.getIndexes();
   ```

2. 查看索引是否创建成功

   ```html
   db.getLastError();
   ```

3. 删除索引

   ```html
   db.accounts.dropIndex( { "tax-id": 1 } )
   ```

4. 新建索引是一件既费时又浪费资源的事情, 默认情况下, MongoDB会尽可能快地创建索引, 阻塞所有对数据库的读请求和写请求, 一直到索引创建完成. 如果希望数据库在创建索引的同时仍然能够处理 读写请求, 可以在创建索引时指定 `background` 选项. 这样在创建索引时, 如果有新的数据库请求需要处理, 创建索引的过程就会暂停一下, 但仍然会对应用程序影响较大.


### 固定集合

固定集合需要事先创建好, 而且它的大小是固定的. __向一个已经满了的固定结合中插入数据会咋样? 答案是, 固定集合的行为类似于循环队列. 如果已经没有了空间了, 最老的文档会被删除以释放空间. 新插入的文档会占据这块空间.__

### 创建固定集合

```html
//创建一个名为 log 的集合, 允许存储最大文档数为 100 , 最大的空间为5M的文档集合
db.createCollection("log",{capped:true,size:5242880,max:100})
```

### 自然排序

1. 对于固定集合可以进行一种特殊的排序, 成为自然排序。自然排序返回结果集中文档的顺序就是文档在磁盘上的顺序。 使用 `{"$natural":1}` 进行排序。

2. 对于大多数集合来说， 自然排序的意义不大， 因为文档的位置经常变动。但是，固定集合中的文档 是按照文档被插入的顺序保存的。自然顺序就是文档的 插入顺序。

   ```html
   //按照自然顺序的正序排序
   db.log.find().sort({"$natural":1});
   //按照自然顺序的倒序排序
   db.log.find().sort({"$natural":-1});
   ```

### TTl索引

1. 对于固定集合中的内容合适被覆盖, 只拥有非常有限的控制权限,如果需要更加类或的老化移出系统( age-out system )。可以使用TTL索引（time-to-live index）。这种索引允许为每一个文档设置一个超时时间。一个文档到达预设置的老化程度之后就会被删除。这种类型的索引对于缓存问题非常有用。

2. 数据到期

   - TTL索引在索引字段值超过指定的秒数后过期文档; 即，到期阈值是索引字段值加上指定的秒数。
   - 如果字段是数组，并且索引中有多个日期值，则MongoDB使用数组中的*最低*（即最早）日期值来计算到期阈值。
   - 如果文档中的索引字段不是日期 或包含日期值的数组，则文档将不会过期。
   - 如果文档不包含索引字段，则文档不会过期

3. 创建

   ```javascript
   //创建一个10秒以后自动删除
   db.log.createIndex({"cTiem":1},{expireAfterSeconds:10});
   //写入数据
   db.log.insert({"_id":1,"cTime":new Date()});
   ```

### 地理空间索引

1. 创建空间位置索引 `https://blog.csdn.net/zhangzhebjut/article/details/23021073` 









