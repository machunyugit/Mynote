## 类型、运算符与表达式

### 数据类型

```c
char
int
float
double
```

### 常量

```c
//定义
	#define INCHES_PER_FOOT 12

/*
	常量表达式: 是仅仅只包含常量的表达式。这种表达式在编译时求值，而不在运行时求值。它可以出现在常量可以出现的任何位置。
*/
	#define MAXLINE 1000
	chat line[MAXLINE+1];

/*
	1. 字符串常量：就是字符数组。字符串的内部表示使用一个空字符'\0' 作为串的结尾，因此。存储字符串的物理存储单元数比在双括号的字符数多一个。这种表示方法也说明，c 语言对字符串的长度没有限制。但程序必须扫描完整的字符串后才能确定字符串的长度。
	2. 'x' 和 "x" 区别：前者是一个整数，后者是一个包含一个字符（x）以及一个结束符 '\0' 的字符数组。
*/
	"hello, world"
```

### 声明

```c
int lower, upper, step;  //批量声明
int c;  //单个声明
int i = 0; //声明并且初始化

/*
	1. 任何变量的声明都可以使用 const 限定符限定。
	2. 该限定符指定变量的值不能被修改。
	3. 对数组而言，const 限定符指定数组所有元素的值都不能被修改。
*/
	const double e = 2.7189939303;
	const char msg[] = "warning: ";

/*
  const 限定符也可配合数组参数使用，它表明函数不能修改数组元素的值：
*/
  int strlen(const char[]);
```

### 类型转换

1. 标准库文件 `<ctype.h>` 定义了一组与字符集无关的测试和转换函数。

### 作用域规则

1. 变量的声名和定义，变量声明用于说明变量的属性（主要是变量的类型），而变量定义除此之外换将引起存储器的分配。

2. `extern` ：在外部变量定义之前是使用该变量，或者外部变量的定义与变量的使用不在同一个源文件中。则必须在相应的变量声明中强制性地使用关键字 extern。**extern 声明数组的时候不一定要指定数组的长度。** 

   ```c
   //module.c
     #include <stdio.h>
     int m = 100;
     void func(){
       printf("Multiple file pro\n");
     }
   //main.c
     #include <stdio.h>
     extern void func();
     extern int m;
   
     int n = 200;
     int main(){
       func();
       printf("m = %d,n = %d\n",m,n);
       return 0;
     }
   
   //gcc -o main.c module.c hello
   
   //数组的声明
     extern double val[];
   ```

### 静态变量

1. 对于静态**全局变量**来说，针对某一源文件的以static声明的文件级变量与函数的作用域只限于文件内（只在文件可见）。可以用来限定变量作用域。
2. 在函数内以static声明的变量虽然与自动局部变量的作用域相同（即作用域都只限于函数内），但存储空间是以静态分配而非默认的自动分配方式获取的，因而存储空间所在区域不同（一般来说，静态分配时存储空间于编译时在程序数据段分配，一次分配全程有效；而自动分配时存储空间则是于调用栈上分配，只在调用时分配与释放），且两次调用间变量值始终保持一致；必须注意，静态局部变量只能初始化一次，这是由编译器来保证实现。

```c
#include <stdio.h>

static int f = 0; //只限当前源文件使用，同时这个变量名也不会和在其他文件的相同名字相冲突。
void func() {
	static int x = 0; // 在对func的三次调用中,x只进行一次初始化
	printf("%d\n", x); // 输出x的值
	x = x + 1;
}

int main(int argc, char * const argv[]) {
	func(); // 输出0
	func(); // 输出1
	func(); // 输出2
	return 0;
}
```

### 寄存器变量

1. 使用场景：当对一个变量频繁读写时，需要反复访问内存，从而花费大量的存取时间。通过 register 可以将这种变量存放在 CPU 的寄存器中。使用时，不需要访问内存，而直接从寄存器中读写，从而提高效率。

2. 声明：只能在局部变量和形参才可以定义为寄存器变量。

3. `register` 是一个建议型关键字，意指程序建议该变量放在寄存器中，但最终该变量可能因为条件不满足并未成为寄存器变量，而是被放在存储器中，但编译器不会报错。

   ```c
   #include <stdio.h>
   int add(int n);
   
   int main(int argc, char * const argv[]) {
   	int d = add(10);
       printf("%d\n", d);
   	return 0;
   }
   
   int add(int n){
     register int i,s =0;
     for(i=1;i<=n;i++){
       s = s+i;
     }
     return s;
   }
   ```

### 初始化

1. 在不进行显示初始化的情况下，全局变量和静态变量都将初始化为0，而局部变量和寄存器变量的初值则没有定义。

2. 对于全局变量与静态变量来说，初始化表达式必须时常量表达式，且只初始化一次。对于局部变量与寄存器变量，则在每次进入函数或程序块时都将初始化。

3. 数组的初始化。

   ```c
   //正确的初始化	
     int days[] = {31,28,31,30};
   
   /*
     1. 当省略数组的长度时，编译器将把花括号中初始化表达式的个数作为数组的长度。
     2. 如果初始化表达式的个数比数组元素少，则对外部变量、静态变量和自动变量来说，没有初始化表达式的元素将被初始化为0；如果初始化表达式的个数比数组元素多，则是错误。
     3. 不能一次将一个初始化表达式指定给多个数组元素，也不能跳过前面的数字元素直接初始化后面的数组元素。
   */
   	int day[],int ff[] = {31,32,33}; //error
   
   /*
     字符串数组声明
   */
     char pattern[] = "ould";
     char pattern[] = {'o','u','l','d'}; //等价
   ```

### c 预处理器

## 指针和数组

指针是一种保存变量地址的变量。

### 指针与地址

1. 一元运算符 `&` 可用于取一个对象的地址

   ```c
   //把c的地址赋值给变量p，称p为指向c的指针。 
   p = &c;
   ```

2. 地址运算符 `&` 只能应用于内存中的对象，即变量与数组元素。它不能作用于表达式、常量或者 `register` 类型的变量。

3. 一元运算符 `*` 是间接寻址或者间接引用运算符。当它作用于指针时，将访问指针所指向的对象。

   ```c
   int x = 1,y = 2, z[10];
   int *ip /* ip 是一个int的指针 */
   ip = &x; /* ip 现在指向变量 x*/
   y = *ip /* y 现在为1 */
   *ip = 0; /* x 现在是0 */
   ```

4. **声明**

   ```c
   //声明指针
     int *ip;
   //使用
     /*
      int x = 1;
      int *ip = &x;
      1. 如果指针ip指向整型变量，那么在x可以出现的任何上下文中都可以使用 *ip。
         *ip = *ip +10;
      2. 把 *ip 指向的对象的值取出来并加1，然后再将结果复制给 ip。
         *ip += 1
     */
   ```

5. 指针只能指向某种特定类型的对象，也就是说，每个指针都必须指向某种特定的数据类型。（一个例外情况是指向 void 类型的指针可以存放指向任何类型的指针，但它不能间接引用其自身）。

### 指针与函数参数

c 语言是以传值的方式将参数传递给被调用函数。

```c
#include <stdio.h>
void swap(int *px, int *py);

int main()
{
  int a = 10, b = 9;
  swap(&a, &b);
  printf("a=%d,b=%d\n", a, b);
}

void swap(int *px, int *py)
{
  int temp;
  temp = *px;
  *px = *py;
  *py = temp;
}
```

### 指针与数组

1. 当把数组名传递给一个函数时，实际上传递的是该数组第一个元素的地址。在调用函数中，该参数是一个局部变量，因此，数组名参数必须是一个指针，也就是一个存储地址值的变量。

   ```c
   //eg
     int strlen(char *s)
     {
       int n;
       for (n = 0; *s != '\0', s++){
         n++;
       }
       return n;
     }
   ```

2. 数组名和指针之间有一个不同之处，指针是一个变量，因此，在 c 语言中，语句 `pa=a` 和 `pa++` 都是合法的。但数组名不是变量，因此，类似于 `a =pa` 和 `a++ `形式的语句是非法的。

3. 在函数定义中，下面的方式是等价的。

   ```c
   int strlen(char s[]);
   int strlen(char *s);
   ```

### 地址算术运算

1. 指针与整数之间不能相互转换，但 0 是唯一的例外：常量 0 可以赋值给指针，指针也可以和常量 0 比较。程序中经常用符号常量 `NULL` 代替常量 0。符号常量 `NULL` 定义在标准头文件 `<stddef.h>` 中。

   ```c
   #include <stdio.h>
   
   int main()
   {
     int *a = 0;
     int b = 9;
     a = &b;
     a = 0;
   }
   ```

2. 在某些情况下对指针可以进行比较运算。例如，如果指针 p 和 q 指同一个数组的成员，那么它们之间可以进行类似于 `==`、`!=` 、`<`、`>=`。但是指向不同数组的元素的指针之间的算术或者比较运算没有意义。

3. 任何指针与 0 进行相等和不等的比较运算都有意义。

   ```c
   #include <stdio.h>
   
   int main()
   {
     int a[5] = {1,2,3,4,5};
     int *b,*c,*d;
     b = &a[1];
     c = &a[2];
     d = &a[1];
     printf("%d\n",c > d); // 1 true
     printf("%d\n",d > c); // 0 false
     printf("%d\n",d == b); //1 true
     printf("%d\n",d >= b); // 1 true
   }
   ```

4. 指针运算的意义

   * 头文件`<stddef.h>` 中定义 `ptrdiff_t` 足以表示两个指针之间（字符串的字符数）的带符号差值。（示例 2 中）

   ```c
   #include <stdio.h>
   
   int main()
   {
     int *p;
     int a[3] = {1,2,3};
     p = a; //指向 a[0] 元素的地址
     /*
       1. 表示指针 p 当前指向的对象之后第 1 个对象的地址。
       2. 而 p 指向的对象的长度则取决于 p 的声明。例如，如果 int 类型占 4 个字节的存储空间，那么在 int 类型的计算中，对应的 n 将按照 4 的倍数来计算的。
     */
     printf("%d\n",*(p+1));
   }
   
   /*
     如果 p 和 q 指向相同数组中的元素，且 p < q，那么 q - p + 1 就是位于 p 和 q 指向的元素之间的元素的数目。
   */
   int strlen(char *s)
   {
     char *p = s;
     while (*p != '\0') {
       p++;
     }
     return p-s;
   }
   ```

### 字符指针与函数。

1. 字符串常量是一个字符串数组，在字符串的内部表示中，字符数组以空字符 `'\0'` 结尾。所以，程序可以通过检查空字符找到字符数组的结尾。字符串常量占据的存储单元数也因此比双引号内的字符数大1。

   ```c
   "I am a string"
   ```

2. 进栈和出栈的标准用法。

   ```c
   *p++ = val; /* 将 val 压入栈 */
   val = *--p; /* 将栈顶元素弹出到 val 中 */
   ```

### 指针数组以及指向指针的指针。

