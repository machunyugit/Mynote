## 基础知识

1. 创建新目录时会自动创建了两个文件名：`.` 和 `..` 。点指向当前目录，点点指向父目录。最高层次的根目录中，点点与点相同。
2. 每个进程都有一个**工作目录** ，有时称其为当前工作目录。所有相对路径名都从工作目录开始解释。进程中使用 `chdir` 函数更改其工作目录。
3. UNIX 系统确保每个进程都有一个唯一的数字标识符，称为进程ID。

### 出错处理

1. 当 UNIX 系统函数出错时，通常会返回一个负值，而且整型变量 errno 通常被设置为具有特定信息的值。
2. 对于 errno 应当注意两条规则。第一条规则是：如果没有出错，其值不会被例程清除。因此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将 errno 值设置为0。

## 文件 I/O

### 文件类型

1. 普通文件。包含某种形式的数据。至于这种数据是文本还是二进制数据，对于 UNIX 内核而言并无区别。

2. 目录文件。这种文件包含了其他文件的名字以及指向这些文件有关信息的指针。

3. 块特殊文件。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。

4. 字符特殊文件。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。

5. FIFO。这种类型的文件用于进程间通信，有时也称为命名管道。

6. 套接字。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。

7. 符号链接。这种类型的文件指向另一个文件。

   ```c
   #include <stdio.h>
   #include <sys/stat.h>
   
   int main(int argc, char *argv[])
   {
       int i;
       struct stat buf;
       char *ptr;
       for (i = 1; i < argc; i++)
       {
           printf("%s\n", argv[i]);
           if (lstat(argv[i], &buf) < 0)
           {
               printf("error\n");
               continue;
           }
           if (S_ISREG(buf.st_mode))
           {
               ptr = "regular";
           }
           else if (S_ISDIR(buf.st_mode))
           {
               ptr = "directory";
           }
           else if (S_ISCHR(buf.st_mode))
           {
               ptr = "character special";
           }
           else if (S_ISBLK(buf.st_mode))
           {
               ptr = "block special";
           }
           else if (S_ISFIFO(buf.st_mode))
           {
               ptr = "fifo";
           }
           else if (S_ISLNK(buf.st_mode))
           {
               ptr = "symbolic link";
           }
           else if (S_ISSOCK(buf.st_mode))
           {
               ptr = "socket";
           }
           else
           {
               ptr = "** unknown mode **";
           }
           printf("%s\n", ptr);
       }
   }
   
   // ./file_stat /etc/passwd
   ```


## 标准 I/O 库

标准 I/O 库，它们的操作是围绕流进行。流的**定向** 决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在为定向的流上使用一个多字节 I/O 函数，则将该流的定向和设置为宽定向的。若在未定向的流上使用一个单字节 I/O 函数，则将该流的定向设为字节定向的。

## 进程环境

### C 程序的存储空间布局

1. 正文段。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需有一个副本，正文段常常是只读的，以防止程序由于意外而修改其指令。

2. 初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。

   ```c
   int i = 0;
   ```

3. 未初始化数据段。通常将此段称为 `bss` 段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。函数外的声明

   ```c
   long sum[100];
   ```

4. 栈。局部变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量。

5. 堆。通常在堆中进行动态存储分配。堆位于未初始化数据段和栈之间。

### 存储空间

```c
#include <stdlib.h>

void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);

void free(void *ptr);
```

可能产生的致命性错误是：释放一个已经释放了的块；调用 free 时所用的指针不是3个 alloc 函数的返回值等。如若一个进程调用 malloc 函数，但却忘记调用 free 函数，那么该进程占用的存储空间就会连续增加，这就称为 **泄漏**。如果不调用 free 函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降。

### 环境变量

```c
#include <stdlib.h>

int putenv(char *str);

int setenv(const char *name, const char *value,int rewrite);
int unsetenv(const char *name);
```

环境表（指向实际 name=value 字符串的指针数组）和环境字符串通常存放在进程存储空间的顶部（栈之上）。删除一个字符串很简单，只要先在环境表中找到该指针，然后将所有后续指针都向环境表首部顺序移动一个位置。但是增加一个字符或修改一个现有的字符串就困难得多。环境表和环境字符串通常占用的是进程地址空间的顶部，所以它不能再向高地址方向扩展；同时也不能移动在它之下的各栈帧，所以它也不能向低地址方向扩展。两者组合使得该空间的长度不能再增加。

1. 如果修改一个现有的 name；
   * 如果新 value 的长度少于或等于现有 value 的长度，则只要将新字符串复制到原字符串所用的空间中。
   * 如果新 value 的长度大于原长度，则必须调用 malloc 为新字符串分配空间，然后将新字符串复制到该空间中，接着使环境表中针对 name 的指针指向新分配区。

## 进程控制

1. 每个进程都有一个非负整型表示的唯一进程ID。因为进程ID标识符总是唯一的，常将其用作其他标识符的一部分以保证其唯一性。
2. ID 为 0 的进程通常是调度进程，常常被称为**交换进程** 。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为**系统进程**。

### 函数 fork

```c
#include <unistd.h>

pid_t fork(void); //返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1。
```

1. fork 函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。

2. 子进程和父进程继续执行 fork 调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。

3. 父进程和子进程共享同一个**文件偏移量** 。如果父进程和子进程写同一个描述符指向的文件，但又没有任何形式的同步（如使父进程等待子进程），那么它们的输出就会互相混合。

4. `fork` 函数用法
   * 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的-- 父进程等待客户端的服务请求。当这种请求到达时，父进程调用 fork，使子进程处理此请求。父进程则继续等待下一个服务请求。
   * 一个进程要执行一个不同的程序。这对 shell 是常见的情况。

### 函数 exit



