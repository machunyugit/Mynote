## 基础知识

1. 创建新目录时会自动创建了两个文件名：`.` 和 `..` 。点指向当前目录，点点指向父目录。最高层次的根目录中，点点与点相同。
2. 每个进程都有一个**工作目录** ，有时称其为当前工作目录。所有相对路径名都从工作目录开始解释。进程中使用 `chdir` 函数更改其工作目录。
3. UNIX 系统确保每个进程都有一个唯一的数字标识符，称为进程ID。

### 出错处理

1. 当 UNIX 系统函数出错时，通常会返回一个负值，而且整型变量 errno 通常被设置为具有特定信息的值。
2. 对于 errno 应当注意两条规则。第一条规则是：如果没有出错，其值不会被例程清除。因此，仅当函数的返回值指明出错时，才检验其值。第二条规则是：任何函数都不会将 errno 值设置为0。

## 文件 I/O

### 文件类型

1. 普通文件。包含某种形式的数据。至于这种数据是文本还是二进制数据，对于 UNIX 内核而言并无区别。

2. 目录文件。这种文件包含了其他文件的名字以及指向这些文件有关信息的指针。

3. 块特殊文件。这种类型的文件提供对设备（如磁盘）带缓冲的访问，每次访问以固定长度为单位进行。

4. 字符特殊文件。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的所有设备要么是字符特殊文件，要么是块特殊文件。

5. FIFO。这种类型的文件用于进程间通信，有时也称为命名管道。

6. 套接字。这种类型的文件用于进程间的网络通信。套接字也可用于在一台宿主机上进程之间的非网络通信。

7. 符号链接。这种类型的文件指向另一个文件。

   ```c
   #include <stdio.h>
   #include <sys/stat.h>
   
   int main(int argc, char *argv[])
   {
       int i;
       struct stat buf;
       char *ptr;
       for (i = 1; i < argc; i++)
       {
           printf("%s\n", argv[i]);
           if (lstat(argv[i], &buf) < 0)
           {
               printf("error\n");
               continue;
           }
           if (S_ISREG(buf.st_mode))
           {
               ptr = "regular";
           }
           else if (S_ISDIR(buf.st_mode))
           {
               ptr = "directory";
           }
           else if (S_ISCHR(buf.st_mode))
           {
               ptr = "character special";
           }
           else if (S_ISBLK(buf.st_mode))
           {
               ptr = "block special";
           }
           else if (S_ISFIFO(buf.st_mode))
           {
               ptr = "fifo";
           }
           else if (S_ISLNK(buf.st_mode))
           {
               ptr = "symbolic link";
           }
           else if (S_ISSOCK(buf.st_mode))
           {
               ptr = "socket";
           }
           else
           {
               ptr = "** unknown mode **";
           }
           printf("%s\n", ptr);
       }
   }
   
   // ./file_stat /etc/passwd
   ```


## 标准 I/O 库

标准 I/O 库，它们的操作是围绕流进行。流的**定向** 决定了所读、写的字符是单字节还是多字节的。当一个流最初被创建时，它并没有定向。如若在为定向的流上使用一个多字节 I/O 函数，则将该流的定向和设置为宽定向的。若在未定向的流上使用一个单字节 I/O 函数，则将该流的定向设为字节定向的。

## 进程环境

### C 程序的存储空间布局

1. 正文段。这是由 CPU 执行的机器指令部分。通常，正文段是可共享的，所以即使是频繁执行的程序在存储器中也只需有一个副本，正文段常常是只读的，以防止程序由于意外而修改其指令。

2. 初始化数据段。通常将此段称为数据段，它包含了程序中需明确地赋初值的变量。

   ```c
   int i = 0;
   ```

3. 未初始化数据段。通常将此段称为 `bss` 段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。函数外的声明

   ```c
   long sum[100];
   ```

4. 栈。局部变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息。然后，最近被调用的函数在栈上为其自动和临时变量分配存储空间。通过以这种方式使用栈，C递归函数可以工作。递归函数每次调用自身时，就用一个新的栈帧，因此一次函数调用实例中的变量集不会影响另一次函数调用实例中的变量。

5. 堆。通常在堆中进行动态存储分配。堆位于未初始化数据段和栈之间。

### 存储空间

```c
#include <stdlib.h>

void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);

void free(void *ptr);
```

可能产生的致命性错误是：释放一个已经释放了的块；调用 free 时所用的指针不是3个 alloc 函数的返回值等。如若一个进程调用 malloc 函数，但却忘记调用 free 函数，那么该进程占用的存储空间就会连续增加，这就称为 **泄漏**。如果不调用 free 函数释放不再使用的空间，那么进程地址空间长度就会慢慢增加，直至不再有空闲空间。此时，由于过度的换页开销，会造成性能下降。

## 进程

1. 每个进程都有一个非负整型表示的唯一进程ID。
2. ID 为 0 的进程通常是调度进程，常常被称为交换进程。该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。
3. `fork` 函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。
4. 子进程和父进程继续执行 fork 调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。

```c
#inlude <unistd.h>

pid_t getpid(void); //返回值：调用进程的进程ID
pid_t getppid(void); //返回值：调用进程的父进程ID
uid_t getuid(void); // 返回值：调用进程的实际用户ID
uid_t geteuid(void); //返回值：调用进程的有效用户ID
gid_t getgid(void); //返回值：调用进程的实际组
gid_t getegid(void); //返回值：调用进程的有效组ID
pid_t fork(void); //返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1。
```

