# 杂项

## 其它

1. [为什么需要动态分配内存。](<https://blog.csdn.net/a1232345/article/details/40650493>)

## 内联函数

### 概念

**内联函数**是那些定义较小且在发生其函数调用的位置处被替换的函数。函数替换完全是编译器的选择。

### 示例

```c
#include <stdio.h>

//请在内联之前使用“静态”。使用static关键字会强制编译器在链接器中考虑此内联函数。

static inline int add(int x, int y, int z)
{
    return x + y + z;
}
int main()
{
    int x = 1;
    int y = 2;
    int z = 3;

    printf("add %d\n",add(x,y,z));
    return 0;
}
```

### [场景](<http://c.biancheng.net/cpp/html/933.html>)

1. 函数调用也会带来降低效率的问题，因为调用函数实际上将程序执行顺序转移到函数所存放在内存中某个地址，将函数的程序内容执行完后，再返回到转去执行该函数前的地方。这种转移操作要求在转去前要保护现场并记忆执行的地址，转回后先要恢复现场，并按原来保存地址继续执行。因此，函数调用要有一定的时间和空间方面的开销，于是将影响其效率。特别是对于一些函数体代码不是很大，但又频繁地被调用的函数来讲，解决其效率问题更为重要。
2. 在程序编译时，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体来进行替换。显然，这种做法不会产生转去转回的问题，但是由于在编译时将函数休中的代码被替代到程序中，因此会增加目标程序代码量，进而增加空间开销，而在时间代销上不像函数调用时那么大，可见它是以目标代码的增加为代价来换取时间的节省。

### 注意

1. 在内联函数内不允许用循环语句和开关语句。
2. 内联函数的定义必须出现在内联函数第一次被调用之前。
3. 本栏目讲到的类结构中所有在类说明内部定义的函数是内联函数。

## `#include`

```c
#include <stdHeader.h>
#include "myHeader.h"
```

1. 使用尖括号`< >`  和双引号`" "` 的区别在于头文件的搜索路径不同：
   * 使用尖括号`< >`，编译器会到系统路径下查找头文件。
   * 而使用双引号`" "`，编译器首先在当前目录下查找头文件，如果没有找到，再到系统路径下查找。

## 防止c语言头文件被重复包含

```c
#ifndef _XYZ_H
#define _XYZ_H
/* 头文件内容 */
#endif
```

1. 第一次包含头文件，会定义宏 `_XYZ_H` ，并执行“头文件内容”部分的代码；第二次包含时因为已经定义了宏_XYZ_H，不会重复执行“头文件内容”部分的代码。也就是说，头文件只在第一次包含时起作用，再次包含无效。

## 编译系统

```c
#include <stdio.h>
int main()
{
    printf("%s","hello world");
    return 0;
}
```

1. 预处理(cpp)根据字符`#` 开头的命令，修改原始的c程序。比如上面代码中第一行开头的`#include <stdio.h>` 命令告诉预处理器读取系统头文件`stdio.h` 命令告诉预处理器读取系统头文件`stdio.h` 的内容，并把它直接插入到程序文本中。（`hello.i`）
2. 编译阶段。编译器(cel)将文本`hello.i` 翻译成文本文件`hello.s`，它包含一个汇编语言程序。汇编语言程序中的每条语句都以一种表中的文本格式确切地描述了一条低级机器语言指令。
3. 汇编阶段。汇编器(as)将`hello.s` 翻译成机器语言指令，并将结果保存在目标文件`hello.o` 。该文件是一个二进制文件，它的字节编码是机器语言指令而不是字符。
4. 链接阶段。hello 程序调用了`printf` 函数，它是每个c编译器都会提供的标准c库中的一个函数。`printf` 函数存在于一个名为`printf.o` 的单独预编译好了的目标文件中，而这个文件必须以某中方式合并到`hello.o` 文件中。链接器就负责处理这种合并。结果就是得到`hello`文件。它是一个可执行目标文件（或者简称为可执行文件），可以被加载都是内存中，有系统执行。

## 字符串声明

```c
char str[] = "https://google.com";
char *pStr = "https://google.com";
```

它们最根本的区别是在内存中的存储区域不一样，字符数组存储在全局数据区或栈区，第二种形式的字符串存储在常量区。全局数据区和栈区的字符串（也包括其他数据）有读取和写入的权限，而常量区的字符串（也包括其他数据）只有读取权限，没有写入权限。

