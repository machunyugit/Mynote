## 系统 I/O

### 系统级 I/O

1. 输入/输出（I/O）是在主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据的过程。输入操作是从 I/O 设备复制数据到主存，而输出操作是从主存复制数据到 I/O 设备。

#### Unix I/O

1. 所有的 I/O 设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。
2. **打开文件** 。一个应用程序通过要求内核打开相应的文件，来宣告它想要访问一个 I/O 设备。内核返回一个小的非负整数，叫做**描述符**。
3. Linux shell 创建的每个进程开始时都有三个打开的文件：标准输入（描述符为0）、标准输出（描述符1）和标准错误（描述符为2）。头文件 `<unistd.h>` 定一个了常量 `STDIN_FILENO（0）` 、`STDOUT_FILENO（1）` 、`STDERR_FILENO（2）` ，它们可用代替显式的描述符值。
4. **改变当前的文件位置。** 对于每个打开的文件，内核保持着一个文件位置 k，初始为0。这个文件位置是从文件开头起始的字节偏移量。
5. **读写文件。** 一个读操作就是从文件复制 n > 0 个字节到内存，从当前文件位置 k 开始，然后将 k 增加到 k + n。给定一个大小为 m 字节的文件，当 k >= m 时执行读操作会触发一个称为 end-of-file（EOF）的条件，应用能检测到这个条件。在文件结尾处并没有明确的 "EOF符号"。
6. **关闭文件。** 当应用完成了对文件的访问之后，它就通知内核关闭这个文件。作为响应，内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

#### 共享文件

1. **描述符表。**每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。每个打开的描述符表项指向**文件表**中的一个表项。
2. **文件表。** 打开文件的集合是有一张文件表来表示的。所有的进程共享这张表。每个文件表的表项组成包括当前的文件位置、引用计数 （即当前指向该表项的描述符表项数），以及一个指向 v-node 表中对应表项的指针。关闭一个描述符会减少相应的文件表表项中引用计数。内核不回删除这个文件表表项，直到它的引用计数为零。
3. `V-node ` 表。所有的进程共享这张 v-node 表。每个表项包含 stat 结构中的大多数信息，包括 st_mode 和 st_size 成员。
4. **父子进程共享文件** ，父进程调用了 fork 后，子进程有一个父进程描述符表的副本。父子进程共享相同的打开文件表集合，因此共享相同的文件位置。在内核删除相应文件表表项之前，父子进程必须都关闭了它们的描述符。

#### I/O 重定向

一种方式是使用 dup2 函数。

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
/*
	dup2 函数复制描述符表表项 oldfd 到描述符表表项 newfd，覆盖描述符表表项 newfd 以前的内容。如果 newfd 已经打开了，dup2 会在复制 oldfd 之前关闭 newfd。
*/
```

#### 标准 I/O

1. 标准 I/O 库将一个打开的文件模型化为一个流。一个流就是一个指向 FILE 类型的结构和指针。每个 c 程序开始时都有三个打开的流 stdin、stdout 和 stderr。
2. 类型为 FILE 的流是对文件描述符 和 流缓冲区 的抽象。流缓冲区的目的：就是使开销较高的 Linux I/O 系统调用的数量尽可能得小。例如，假设我们有一个程序，它反复调用标准 I/O 的 getc 函数，每次调用返回文件的下一个字符。当第一次调用 getc 时，库通过调用一次 read 函数来填充流缓冲区，然后将缓冲区中的第一个字节返回给应用程序。只要缓冲区中还有未读的字节，接下来对 getc 的调用就能直接从流缓冲区得到数据。

### 网络编程

