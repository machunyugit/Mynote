## `<unistd.h>`

### 常量

1. `STDIN_FILENO（0）` 、`STDOUT_FILENO（1）` 、`STDERR_FILENO（2）` 表示标准输入（描述符为0）、标准输出（描述符1）和标准错误（描述符为2）。

```c
#include <unistd.h>

//函数 close 关闭一个打开文件
  int close(int fd);
//lseek 当前文件偏移量，用以度量从文件开始处计算的字节数。
  off_t lseek(int fd, off_t offset, int whence);
      //whence 是 SEEK_SET,则将该文件的偏移量设置为距离文件开始处 offset 个字节。
      //whence 是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset，offset可为正或负。
      //whence 是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset，offset可为正或负。
//redad 函数从打开文件中读数据。
  ssize_t read(int fd,void *buf, size_t nbytes);
//redad 函数从打开文件中读数据。
  ssize_t write(int fd,void *buf, size_t nbytes);

//允许原子性地定位并执行I/O。
  ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
  ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

//用来复制一个现有的文件描述符。若成功，返回新的文件描述符。若出错，返回-1；
  int dup(int fd);
  int dup2(int fd, int fd2);

//延迟写
  //若成功返回0，若出错，返回-1
  int fsync(int fd);  //函数只对由文件描述符 fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。

  void sync(void); //将修改过的块缓存区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。
```

## `<string.h>`

```c
#include <string.h>

//返回值：指向消息字符串的指针
  char *strerror(int errnumm);//示例1
```

## `<stdio.h>`

```c
#include <stdio.h>

//首先输出由 msg 指向的字符串，然后是一个冒号，一个空格，接着是对应于 errno 值的出错消息，最后是一个换行符。
  void perror(const char *msg);//示例1

  void setbuf(FILE *restrict fp, char *restrict buf);
  int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
   /*
     _IOFBF 全缓冲
     _IOLBF 行缓冲
     _IONBF 不带缓冲
   */
```

## `<stdlib.h>`

```c
#include <stdlib.h>

//atexit 函数注册的函数，将由exit自动调用。调用函数的顺序与它们注册时候的顺序相反。同一函数如若注册多次，也会被调用多次。
  int atexit(void (*func) (void)); //例4

// 下面 3 个函数返回值：若成功，返回非空指针；若出错，返回 null。
	void *malloc(size_t newsize);
  void *calloc(size_t nobj,size_t size);
  void *realloc(void *ptr,size_t newsize);

  void free(void *ptr);
```

## `<fcntl.h>`

```c
#include <fcntl.h>

//... 说明余下的参数的数量及其类型是可变的。示例2
  int open(const char *path, int oflag, ...);
  //path 参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中开始地址。
  int openat(int fd, const char *path, int oflag, ...)
     //下面5个常量中必须指定一个且只能指定一个。
     //O_RDONLY  只读打开
     //O_WRONLY  只写打开
     //O_RDWR    读、写打开
     //O_EXEC    只执行打开
     //O_SEARCH  只搜索打开（应用于目录）
     //下面的是可选的
     //O_APPEND  每次写时都追加到文件尾端。
     //O_DIRECTORY 如果path 引用的不是目录，则出错
//创建一个新文件
    //返回值：若成功，返回只写打开的文件描述符；错误，返回-1
    int creat(const char *path, mode_t mode);
```

## `<sys/stat.h>`

```c
#include <sys/stat.h>

//返回此文件有关的信息结构
  int stat(const char *restrict pathname, struct stat *restrict buf);
//返回描述fd有关的信息结构
  int fstat(int fd, struct stat *buf);
//返回符号链接的有关信息
  int lstat(const chat *restrict pathname, struct stat *restrict buf);
//返回一个相对于 fd 参数的路径名返回文件统计信息。
  //当 fd 参数的值为 AT_FDCWD ，并且 pathname 参数是一个相对路径名，fstatat会计算相对于当前目录的pathname 参数。如果pathname 是一个绝对路径，fd 参数就会被忽略。
  //flag 参数控制着是否跟随着一个符号链接。当 AT_SYMLINK_NOFOLLOW 标志被设置时，返回的是符号链接所指向的实际文件的信息。
  int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
```

## `<wchar.h>`

```c
#include <wchar.h>
//若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0
    int fwide(FILE *fp, int mode);
```

## 示例

1. `strerror` 和 `perror`

   ```c
   #include <stdio.h>
   #include <string.h>
   #include <errno.h>
   
   int main(int argc, char *argv[])
   {
       fprintf(stderr, "EACCES:%s\n", strerror(EACCES));
       errno = ENOENT;
       //将程序名 (argv[0],其值为./1_error)作为参数传递给 perror。
       perror(argv[0]);
       return 0;
   }
   
   /*
   执行结果
   ./1_error
      EACCES:Permission denied
      ./1_error: No such file or directory
   */
   ```

2. `open` 和 `openat`

   ```c
   #include <stdio.h>
   #include <fcntl.h>
   
   int main()
   {
       //AT_FDCWD 表示当前工作目录
       int fd = openat(AT_FDCWD,"1_error",O_RDONLY);
       printf("%d\n",fd);
       return 0;
   }
   ```

3. `lseek`

   ```c
   #include <unistd.h>
   #include <stdio.h>
   
   int main()
   {
       //查看标准输入是否可以设置偏移量
       if(lseek(STDIN_FILENO,0,SEEK_CUR) == -1) {
           printf("cannot seek\n");
       } else {
           printf("seek ok\n");
       }
       return 0;
   }
   ```

4. `atexit`

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   void bye(void)
   {
       printf("That was all,folks\n");
   }
   
   int main()
   {
       atexit(bye);
       exit(EXIT_SUCCESS);
   }
   ```

   