## `<unistd.h>`

### 常量

1. `STDIN_FILENO（0）` 、`STDOUT_FILENO（1）` 、`STDERR_FILENO（2）` 表示标准输入（描述符为0）、标准输出（描述符1）和标准错误（描述符为2）。

```c
#include <unistd.h>

//函数 close 关闭一个打开文件
  int close(int fd);
//lseek 当前文件偏移量，用以度量从文件开始处计算的字节数。
  off_t lseek(int fd, off_t offset, int whence);
      //whence 是 SEEK_SET,则将该文件的偏移量设置为距离文件开始处 offset 个字节。
      //whence 是 SEEK_CUR,则将该文件的偏移量设置为其当前值加 offset，offset可为正或负。
      //whence 是 SEEK_END,则将该文件的偏移量设置为文件长度加 offset，offset可为正或负。
//redad 函数从打开文件中读数据。
  ssize_t read(int fd,void *buf, size_t nbytes);
//redad 函数从打开文件中读数据。
  ssize_t write(int fd,void *buf, size_t nbytes);

//允许原子性地定位并执行I/O。
  ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
  ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

//用来复制一个现有的文件描述符。若成功，返回新的文件描述符。若出错，返回-1；
  int dup(int fd);
  int dup2(int fd, int fd2);

//延迟写
  //若成功返回0，若出错，返回-1
  int fsync(int fd);  //函数只对由文件描述符 fd指定的一个文件起作用，并且等待写磁盘操作结束才返回。

  void sync(void); //将修改过的块缓存区排入写队列，然后就返回，它并不等待实际写磁盘操作结束。

//进程控制
  pid_t getpid(void); //返回值：调用进程的进程ID
  pid_t getppid(void); //返回值：调用进程的父进程ID
  uid_t getuid(void); // 返回值：调用进程的实际用户ID
  uid_t geteuid(void); //返回值：调用进程的有效用户ID
  gid_t getgid(void); //返回值：调用进程的实际组
  gid_t getegid(void); //返回值：调用进程的有效组ID
  
//fork
  pid_t fork(void); //返回值：子进程返回0，父进程返回子进程ID；若出错，返回-1。

/*
  修改 setgit 函数设置实际组ID和有效组ID
  两个函数返回值：若成功。返回0；若出错，返回-1
  功能：
    1. 若进程具有超级用户特权，则 setuid 函数将实际用户ID、有效用户ID以及保存的设置用户ID设置为 uid。
    2. 若进程没有超级用户特权，但是 uid 等于实际用户ID或保存的设置用户ID，则 setuid 只将有效用户ID设置为uid。不更改实际用户ID和保存的设置用户ID。
    3. 如果上面两个条件都不满足，则 errno 设置为 EPERM，并返回 -1。
*/
  int setuid(uid_t uid);
  int setgit(gid_t gid);
```

## `<string.h>`

```c
#include <string.h>

//返回值：指向消息字符串的指针
  char *strerror(int errnumm);//示例1
```

## `<stdio.h>`

```c
#include <stdio.h>

//首先输出由 msg 指向的字符串，然后是一个冒号，一个空格，接着是对应于 errno 值的出错消息，最后是一个换行符。
  void perror(const char *msg);//示例1

  void setbuf(FILE *restrict fp, char *restrict buf);
  int setvbuf(FILE *restrict fp, char *restrict buf, int mode, size_t size);
   /*
     _IOFBF 全缓冲
     _IOLBF 行缓冲
     _IONBF 不带缓冲
   */
```

## `<stdlib.h>`

```c
#include <stdlib.h>

//atexit 函数注册的函数，将由exit自动调用。调用函数的顺序与它们注册时候的顺序相反。同一函数如若注册多次，也会被调用多次。
  int atexit(void (*func) (void)); //例4

// 下面 3 个函数返回值：若成功，返回非空指针；若出错，返回 null。
	void *malloc(size_t newsize);
  void *calloc(size_t nobj,size_t size);
  void *realloc(void *ptr,size_t newsize);

  void free(void *ptr);

//函数返回值：若成功，返回0；失败返回非0。
  int putenv(char *str);

//两个函数返回值：若成功，返回0；若出错返回-1。
  int setenv(const char *name, const char *value,int rewrite);
  int unsetenv(const char *name);
```

1. `putenv` 	取形式为 `name=value	`

## `<fcntl.h>`

```c
#include <fcntl.h>

//... 说明余下的参数的数量及其类型是可变的。示例2
  int open(const char *path, int oflag, ...);
  //path 参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中开始地址。
  int openat(int fd, const char *path, int oflag, ...)
     //下面5个常量中必须指定一个且只能指定一个。
     //O_RDONLY  只读打开
     //O_WRONLY  只写打开
     //O_RDWR    读、写打开
     //O_EXEC    只执行打开
     //O_SEARCH  只搜索打开（应用于目录）
     //下面的是可选的
     //O_APPEND  每次写时都追加到文件尾端。
     //O_DIRECTORY 如果path 引用的不是目录，则出错
//创建一个新文件
    //返回值：若成功，返回只写打开的文件描述符；错误，返回-1
    int creat(const char *path, mode_t mode);
```

## `<wchar.h>`

```c
#include <wchar.h>
//若流是宽定向的，返回正值；若流是字节定向的，返回负值；若流是未定向的，返回0
    int fwide(FILE *fp, int mode);
```

## `<sys/stat.h>`

```c
#include <sys/stat.h>

//返回此文件有关的信息结构
  int stat(const char *restrict pathname, struct stat *restrict buf);
//返回描述fd有关的信息结构
  int fstat(int fd, struct stat *buf);
//返回符号链接的有关信息
  int lstat(const chat *restrict pathname, struct stat *restrict buf);
//返回一个相对于 fd 参数的路径名返回文件统计信息。
  //当 fd 参数的值为 AT_FDCWD ，并且 pathname 参数是一个相对路径名，fstatat会计算相对于当前目录的pathname 参数。如果pathname 是一个绝对路径，fd 参数就会被忽略。
  //flag 参数控制着是否跟随着一个符号链接。当 AT_SYMLINK_NOFOLLOW 标志被设置时，返回的是符号链接所指向的实际文件的信息。
  int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);
```

## `<sys/wait.h>`

```c
#include <sys/wait.h>

//两个函数返回值：若成功，返回进程ID；若出错，返回0（见后面的说明）或者-1
/*
	作用：
		1. 如果其所有子进程都还在运行，则阻塞。
		2. 如果一个子进程已终止，正等待父进程获取其终止状态，则取得该子进程的终止状态立即返回。
		3. 如果没有任何子进程，则立即出错返回。
	区别：
		1. 在一个子进程终止前，wait 使其调用者阻塞，而 waitpid 有一选项，可使调用者不阻塞。
		2. waitpid 并不等待在其调用之后的第一个终止子进程，它有若干个选项，可以控制它所等待的进程。
	参数：
	  statloc 是一个整形指针，如果 statloc 不是一个空指针，则终止进程的终止状态就存放在它所指向的单元内。如果不关心终止状态，则可将该参数指定为空指针。
	waitpid 函数：
	   pid == -1 等待任一子进程。此种情况下，waitpid 与 wait 等效
	   pid > 0 等待进程 ID 与 pid 相等的子进程。
	   pid == 0 等待组 ID 等于调用进程组ID的任一子进程。
	   pid < -1 等待组ID 等于 pid 绝对值的任一子进程。
		eg.5
*/
  pid_t wait(int *statloc);
  pid_t waitpid(pid_t pid, int *statloc, int options);

  int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
```







## 示例

1. `strerror` 和 `perror`

   ```c
   #include <stdio.h>
   #include <string.h>
   #include <errno.h>
   
   int main(int argc, char *argv[])
   {
       fprintf(stderr, "EACCES:%s\n", strerror(EACCES));
       errno = ENOENT;
       //将程序名 (argv[0],其值为./1_error)作为参数传递给 perror。
       perror(argv[0]);
       return 0;
   }
   
   /*
   执行结果
   ./1_error
      EACCES:Permission denied
      ./1_error: No such file or directory
   */
   ```

2. `open` 和 `openat`

   ```c
   #include <stdio.h>
   #include <fcntl.h>
   
   int main()
   {
       //AT_FDCWD 表示当前工作目录
       int fd = openat(AT_FDCWD,"1_error",O_RDONLY);
       printf("%d\n",fd);
       return 0;
   }
   ```

3. `lseek`

   ```c
   #include <unistd.h>
   #include <stdio.h>
   
   int main()
   {
       //查看标准输入是否可以设置偏移量
       if(lseek(STDIN_FILENO,0,SEEK_CUR) == -1) {
           printf("cannot seek\n");
       } else {
           printf("seek ok\n");
       }
       return 0;
   }
   ```

4. `atexit`

   ```c
   #include <stdio.h>
   #include <stdlib.h>
   
   void bye(void)
   {
       printf("That was all,folks\n");
   }
   
   int main()
   {
       atexit(bye);
       exit(EXIT_SUCCESS);
   }
   ```

5. `wait`

   ```c
   #include <stdlib.h>
   #include <stdio.h>
   #include <unistd.h>
   #include <sys/types.h>
   #include <sys/wait.h>
   
   int main()
   {
       pid_t pid;
       int status, i;
       if(fork() == 0){
           printf("This is the child process. pid = %d\n",getpid());
           exit(6);
       } else {
           sleep(1);
           printf("This is the parent process,wait for child...\n");
           pid = wait(&status);
           i = WEXITSTATUS(status);
           printf("child's pid =%d . exit status=%d\n", pid, i);
       }
       return 0;
   }
   ```

   