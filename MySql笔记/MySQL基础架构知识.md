### 积硅步, 致千里

#### 读写锁

> 某个客户正在读取邮箱, 同时另外一个用户试图删除编号为25的邮件, 会产生什么结果? 结论是不确定, 读的客户可能会报错退出, 也可能读取到不一致的邮箱数据. 
>
> 解决这类经典问题的方法就是并发控制,在处理并发读或者写时, 可以通过实现一个由两种类型的锁组成的锁系统来解决问题.  这两种类型的锁通常被称为__共享锁( shared lock ) 和 排他锁 ( exclusive lock ), 也叫读锁 (read lock) 和 写锁 (write lock)__ 

1. __读锁__ 是共享的, 或者说是互相不阻塞的, 多个客户在同一时刻可以同时读取同一个资源, 而互不干扰
2. __写锁__ 是排他的, 也就是说一个写锁会阻塞其他的写锁和读锁

#### 锁粒度

>一种提高共享资源并发性的方式就是让锁定对象更有选择性. 尽量只锁定需要修改的部分数据, 而不是所有的资源. 更理想的方式是, 只对会修改的数据片进行精确的锁定, 任何时候, 在给定的资源上, 锁定的数据量越少, 则系统的并发程度越高, 只要相互之间不发生冲突即可
>
>
>
>锁的操作 : 获得锁, 检查锁是否已经解除, 释放锁等
>
>
>
>锁策略, 就是在锁的开销和数据的安全性之间寻求平衡

1. 表锁 ( table lock)
   * 表锁是MySQL中最基本的锁策略, 并且是开销最小的策略, 它会锁定整张表, 一个用户在对表进行写操作( 插入, 删除, 更新 ) 前, 需要先获得写锁, 这会阻塞其他用户对该表的所有读写操作, 只有没有写锁是, 其他读取的用户才能获得读锁, __读锁之间是不相互阻塞的__ 
   * 写锁比读锁有更高的优先级, 因此一个写锁请求可能会被插入到读锁队列的前面
2. 行级锁 ( row lock )
   * 行级锁可以最大程度地支持并发处理 ( 同时也带来了最大的锁开销 )
   * 行级锁只在存储引擎实现

#### 事务

1. __事务__ 就是一组原子性的SQL查询, 事务内的语句, 要么全部执行成功, 要么全部执行失败

2. __ACID测试__  : 原子性( atomicity)， 一致性( consistency )， 隔离性 ( isolation ) 和 持久性 ( durability)。 一个运行良好的事务处理系统， 必须具备这些标准特征。

   * 原子性

     一个事务必须被视为一个不可分割的最小工作单元, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚, 对于一个事务来说, 不可能只执行其中的一部分操作

   * 一致性

     数据库总是从一个一致性的状态转换到另外一个一致性的状态。在事务的执行过程中系统出现崩溃， 数据库中的数据也不会损失，因为事务最终没有提交，所以事务中所做的修改也不会保存到数据库中

   * 隔离性

     一个事务所做的修改在最终提交以前，对其他事务时不可见的。

   * 持久性

     一旦事务提交， 则其所做的修改就会永久保存在数据库中，此时即使系统崩溃，修改的数据也不会丢失。持久性是个优点模糊的概念， 实际上持久性分很多不同的级别。

3. 用户可以根据业务是否需要事务处理， 来选择合适的存储引擎。对于一些不需要食物的查询类应用， 选择一个非事务型的存储引擎，可以活得更高的性能。

#### 事务的隔离级别

1. read uncommitted (未提交读)

   事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为__脏读（Dirty Read）__ 。在实际应用中一般很少使用

2. read committed ( 提交读 )

   __大多数数据系统的默认隔离级别都是这个级别（但是MySQL不是）__。read committed 满足： 一个事务从开始直到提交之前，所做的任何修改对其他事务不可见的，这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得到不一样的结果。

3. repeatable read （可重复读）

   * REPEATABLE READ 解决了脏读的问题， 该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。

   * __所谓幻读__ 幻读是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，比如这种修改涉及到表中的“全部数据行”。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入“一行新数据”。那么，以后就会发生操作第一个事务的用户发现表中还存在没有修改的数据行，就好象发生了幻觉一样 

     __指得是当某个事物在读取某个范围内的记录时， 会产生幻行（Phantom Row）。InnoDB存储引擎解决了幻读的问题__ 

4. serializable （可串行化）

   SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单的说，SERIALIZABLE会在读取的每一行数据上都加锁， 所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别

   | 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
   | ---------------- | ---------- | ---------------- | ---------- | ------ |
   | READ UNCOMMITTED | yes        | yes              | yes        | no     |
   | READ COMMITTED   | no         | yes              | yes        | no     |
   | REPEATABLE READ  | no         | no               | yes        | no     |
   | SERIALIZABLE     | no         | no               | no         | yes    |

#### 死锁

1. 死锁是指两个或者多个事务在同一资源上相互占用， 并请求锁定对方占用的资源， 从而导致恶性循环的现象，当多个的事务视图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一个资源时，也会产生死锁。

   >事务1
   >
   >​	START TRANSACTION;
   >
   >​	update stockprice set close = 45.50 where stock_id = 4 and date = '2018-5-1';
   >
   >​	update stockprice set close = 45.50 where stock_id = 3 and date = '2018-5-1';
   >
   >​	COMMIT;
   >
   >事务2
   >
   >​	START TRANSACTION;
   >
   >​	update stockprice set close = 45.50 where stock_id = 3 and date = '2018-5-1';
   >
   >​	update stockprice set close = 45.50 where stock_id = 4 and date = '2018-5-1';
   >
   >​	COMMIT;
   >
   >如果凑巧，两个事务都执行了第一条UPDATE语句，更新了一行数据，同时也锁定了该行数据，接着每个事务都尝试去执行第二条UPDATE语句，却发现该行已经被对方锁定，然后两个事务都等待对方释放锁，同时又持有对方需要的锁，这陷入死循环。除非有外部因素介入才可能解除死锁。

   #### 事务日志

   事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时只需要修改其内存拷贝，再把该修改行为记录到持久在硬盘上的事务日志中，而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志的操作是磁盘上一小块区域内的顺序 I/O，而不像随机 I/O需要在磁盘的说个地方移动磁头。所以采用事务日志的方式相对来说要快得多。

   #### MySQL中的事务

   1. MySQL默认采用自动提交（autocommit）模式。也就是说，如果不是显示地开始一个事务，则每个查询都被当作一个事务执行提交操作。

      ```mysql
      mysql> show variables like 'autocommit';
      +---------------+-------+
      | Variable_name | Value |
      +---------------+-------+
      | autocommit    | ON    |
      +---------------+-------+
      1 row in set (0.00 sec)
      
      set session transaction isolation level read committed;
      ```

#### 隐式和显式锁定

InnoDB采用的是两阶段锁定协议。在事务执行过程中，随时都可以执行锁定，锁只有在执行COMMIT或者ROLLBACK的时候才会释放，并且所有的锁是在同一时刻被释放。__隐式锁定__ 

InnoDB还支持通过特定的语句进行__显式锁定__

```mysql
select ... lock in share mode
select ... for update
```

__应用已经将表从MyISAM转换到InnnoDB，但还是显式地使用LOCK TABLES语句。这是没有必要，还会严重影响性能，实际上InnoDB的行级锁工作得更好__

#### 多版本并发控制



