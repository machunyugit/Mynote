### 积硅步, 致千里 

#### 索引的作用

* 创建索引可以大大提高系统的性能。  
* 索引的目的在于提高查询效率，可以类比字典，如果要查“mysql”这个单词，我们肯定需要定位到m字母，然后从下往下找到y字母，再找到剩下的sql。如果没有索引，那么你可能需要把所有单词看一遍才能找到你想要的，如果我想找到m开头的单词呢？或者ze开头的单词呢？是不是觉得如果没有索引，这个事情根本无法完成？ 

#### 索引的原理

* 生活中随处可见索引的例子，如火车站的车次表、图书的目录等。它们的原理都是一样的，通过不断的缩小想要获得数据的范围来筛选出最终想要的结果，同时把随机的事件变成顺序的事件，也就是我们总是通过同一种查找方式来锁定数据。 数据库也是一样，但显然要复杂许多，因为不仅面临着等值查询，还有范围查询(>、<、between、in)、模糊查询(like)、并集查询(or)等等。数据库应该选择怎么样的方式来应对所有的问题呢？我们回想字典的例子，能不能把数据分成段，然后分段查询呢？最简单的如果1000条数据，1到100分成第一段，101到200分成第二段，201到300分成第三段......这样查第250条数据，只要找第三段就可以了，一下子去除了90%的无效数据。但如果是1千万的记录呢，分成几段比较好？稍有算法基础的同学会想到搜索树，其平均复杂度是lgN，具有不错的查询性能。但这里我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道访问磁盘的成本大概是访问内存的十万倍左右，所以简单的搜索树难以满足复杂的应用场景。 

  ```html
       4
    2     6
  1  3  5  7
  ```

- 索引其实是数据的目录, 能快速定位行数据的位置, 

- 索引提高了查询速度降低了增删改的数据, 并非加的越多越好

  ```html
  增加了数据的同时也得修改索引数据
  删除索引,索引节点也得删除
  ```

- 一般找查询频率的列上加而且在重复度列上加效果更好

  __例如在用户表给性别字段加索引, 区分度不高, 但是如果给身份证号加索引是比较好的能快速定位__

#### 索引的类型及作用

1. 普通索引: 普通索引（由关键字KEY或INDEX定义的索引）的唯一任务是加快对数据的访问速度。因此，应该只为那些最经常出现在查询条件（WHERE column=）或排序条件（ORDER BY column）中的数据列创建索引。只要有可能，就应该选择一个数据最整齐、最紧凑的数据列（如一个整数类型的数据列）来创建索引。 

2. 唯一索引 (unique)

   * 普通索引允许被索引的数据列包含重复的值。比如说，因为人有可能同名，所以同一个姓名在同一个“员工个人资料”数据表里可能出现两次或更多次。

   * 如果能确定某个数据列将只包含彼此各不相同的值，在为这个数据列创建索引的时候就应该用关键字UNIQUE把它定义为一个唯一索引。

     * 除了提高数据的查询速度, 同时也对数据做唯一性的约束

     * 一是简化了MySQL对这个索引的管理工作，这个索引也因此而变得更有效率；
     * 二是MySQL会在有新记录插入数据表时，自动检查新记录的这个字段的值是否已经在某个记录的这个字段里出现过了；如果是，MySQL将拒绝插入那条新记录。也就是说，唯一索引可以保证数据记录的唯一性。事实上，在许多场合，人们创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

3. 主键索引 (primary key)

   * 必须为主键字段创建一个索引，这个索引就是所谓的“主索引”。主索引与唯一索引的唯一区别是：前者在定义时使用的关键字是PRIMARY而不是UNIQUE。 

4. 全文索引

   - 在中文状态下几乎无效, __要分词+索引, 一般用第三方解决方案, 如 sphinx__ 

     __注解：InnoDB数据表不支持全文索引。__

5. 外键索引

   如果为某个外键字段定义了一个外键约束条件，MySQL就会定义一个内部索引来帮助自己以最有效率的方式去管理和使用外键约束条件。 

6. 多列索引

   在t_user表id，userName，email字段上创建多列索引（该表只有此索引）：

   ```
   alter table t_user add index USER_INDEX(id, userName, email);
   ```

   组合索引的生效原则是从前往后依次使用生效，如果中间某个索引没有使用，那么断点前面的索引部分起作用，断点后面的索引没有起作用__给 a, b, c三列建立索引__ 

   ```
   (0)    select * from mytable where a=3 and b=5 and c=4;
   abc三个索引都在where条件里面用到了，而且都发挥了作用
   (1)    select * from mytable where  c=4 and b=6 and a=3;
   这条语句列出来只想说明 mysql没有那么笨，where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样
   (2)    select * from mytable where a=3 and c=7;
   a用到索引，b没有用，所以c是没有用到索引效果的
   (3)    select * from mytable where a=3 and b>7 and c=3;
   a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引
   (4)    select * from mytable where b=3 and c=4;
   因为a索引没有使用，所以这里 bc都没有用上索引效果
   (5)    select * from mytable where a>4 and b=7 and c=9;
   a用到了  b没有使用，c没有使用
   (6)    select * from mytable where a=3 order by b;
   a用到了索引，b在结果排序中也用到了索引的效果，前面说了，a下面任意一段的b是排好序的
   (7)    select * from mytable where a=3 order by c;
   a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了，使用 explain 可以看到 filesort
   (8)    select * from mytable where b=3 order by a;
   b没有用到索引，排序中a也没有发挥索引效果
   
   ```

   * 冗余索引

     比如对姓和名建立组合索引,再对名建立索引, 对于名来说建立被两种类型的索引给覆盖

####索引长度 

* 建立索引时, 可以只索引列的前一部分的内容, 比如前10个字符

  * __如 email 后面的字符都是一些区分度不高的, 就没必要建立索引浪费资源__ 

    ```mysql
    #后去追加索引
    create unique index email on tbl_users(email(10))
    ```

* 在为`CHAR`和`VARCHAR`类型的数据列定义索引时，可以把索引的长度限制为一个给定的字符个数（这个数字必须小于这个字段所允许的最大字符个数）。这么做的好处是可以生成一个尺寸比较小、检索速度却比较快的索引文件。

#### 不应该创建索引的列

1. 在查询中很少使用的列上不应该创建索引，因为这些列很少使用到，因此有索引或无索引，并不能提高查询速度，相反由于增加了索引，反而降低了系统维护速度，增大了空间需求；
2. 在只有很少数据值的列上不应该创建索引，很少数据值的列如性别等，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大，增加索引，并不能明显加快检索速度；
3. 当修改性能远远大于检索性能时，不应该创建索引，因为改性能和检索性能是互相矛盾的，当增加索引时，会提高检索性能，但会降低修改性能，当减少索引时，会提高修改性能，但会降低检索性能。因此，当修改性能远大于检索性能时，不应该创建索引。

#### 索引的例子

* 组合索引

  >  1，首先要确定优化的目标，在什么样的业务场景下，表的大小等等。如果表比较小的话，可能都不需要加索引。 
  > 2，哪些字段可以建索引，一般都where、order by 或者 group by 后面的字段。 
  > 3，记录修改的时候需要维护索引，所以会有开销，要衡量建了索引之后的得与失。 
  >
  >   学生表，可以认为name的重复度比较小，而age的重复度比较大，对于单列索引来说，比较适合建在重读度低的列上。
  >
  >  对于select * from students where name='张三’and  age=18; 题主所说的两种情况 
  > A. name 和 age 各自单独建立索引。  
  >   一般来说mysql会选择其中一个索引，name的可能性比较大，因为mysq会统计每个索引上的重复度，选用低重复度的字段。另外一个age的索引就不会用到，但还有维护索引的开销，所以age的索引不需要创建。 
  >
  > B. name和age的联合索引 
  >   这种索引的切合度最好，mysql会直接选用这个索引。但相对单独的name索引来说，维护的成本要大一些，并且索引数据占用的存储空间也要更大一些。 
  >
  >   回过来看，有必要使用联合索引吗？ 我的看法是没有必要，因为学校里可能会有重名的人，但比较少。用name就可以比较精准的找到记录，即使有重复的也比较少。
  >
  >  什么情况下使用联合索引比较好呢？ 举一个例子，大学选认课老师，需要创建一个关系对应表，有2个字段,student_id 和 teacher_id，想要查询某个老师和某个学生是否存在师生关系。 
  >   一个学生会选几十个老师，一个老师会带几百个学生 
  >   如果只为student_id建立索引的情况下，经过索引会选出几十条记录，然后在内存中where一下，去除其余的老师。 
  >   相反如果只为teacher_id建立索引，经过索引会选出几百条记录，然后在内存中where一下，去除其余的学生。 
  >   两种情况都不是最优的，这个时候使用联合索引最合适，通过索引直接找到对应记录。

  