### 积硅步, 致千里

#### 读写锁

> 某个客户正在读取邮箱, 同时另外一个用户试图删除编号为25的邮件, 会产生什么结果? 结论是不确定, 读的客户可能会报错退出, 也可能读取到不一致的邮箱数据. 
>
> 解决这类经典问题的方法就是并发控制,在处理并发读或者写时, 可以通过实现一个由两种类型的锁组成的锁系统来解决问题.  这两种类型的锁通常被称为__共享锁( shared lock ) 和 排他锁 ( exclusive lock ), 也叫读锁 (read lock) 和 写锁 (write lock)__ 

1. __读锁__ 是共享的, 或者说是互相不阻塞的, 多个客户在同一时刻可以同时读取同一个资源, 而互不干扰
2. __写锁__ 是排他的, 也就是说一个写锁会阻塞其他的写锁和读锁

#### 锁粒度

>一种提高共享资源并发性的方式就是让锁定对象更有选择性. 尽量只锁定需要修改的部分数据, 而不是所有的资源. 更理想的方式是, 只对会修改的数据片进行精确的锁定, 任何时候, 在给定的资源上, 锁定的数据量越少, 则系统的并发程度越高, 只要相互之间不发生冲突即可
>
>
>
>锁的操作 : 获得锁, 检查锁是否已经解除, 释放锁等
>
>
>
>锁策略, 就是在锁的开销和数据的安全性之间寻求平衡

1. 表锁 ( table lock)
   * 表锁是MySQL中最基本的锁策略, 并且是开销最小的策略, 它会锁定整张表, 一个用户在对表进行写操作( 插入, 删除, 更新 ) 前, 需要先获得写锁, 这会阻塞其他用户对该表的所有读写操作, 只有没有写锁是, 其他读取的用户才能获得读锁, __读锁之间是不相互阻塞的__ 
   * 写锁比读锁有更高的优先级, 因此一个写锁请求可能会被插入到读锁队列的前面
2. 行级锁 ( row lock )
   * 行级锁可以最大程度地支持并发处理 ( 同时也带来了最大的锁开销 )
   * 行级锁只在存储引擎成实现

#### 事务

1. __事务__ 就是一组原子性的SQL查询, 事务内的语句, 要么全部执行成功, 要么全部执行失败

2. __ACID测试__  : 原子性( atomicity)， 一致性( consistency )， 隔离性 ( isolation ) 和 持久性 ( durability)。 一个运行良好的事务处理系统， 必须具备这些标准特征。

   * 原子性

     一个事务必须被视为一个不可分割的最小工作单元, 整个事务中的所有操作要么全部提交成功, 要么全部失败回滚, 对于一个事务来说, 不可能只执行其中的一部分操作

   * 一致性

     数据库总是从一个一致性的状态转换到另外一个一致性的状态。在事务的执行过程中系统出现崩溃， 数据库中的数据也不会损失，因为事务最终没有提交，所以食物中所做的修改也不会保存到数据库中

   * 隔离性

     一个事务所做的修改在最终提交以前，对其他事务时不可见的。

   * 持久性

     一旦事务提交， 则其所做的修改就会永久保存在数据库中，此时即使系统崩溃，修改的数据也不会丢失。持久性是个优点模糊的概念， 实际上持久性分很多不同的级别。

3. 用户可以根据业务是否需要事务处理， 来选择合适的存储引擎。对于一些不需要食物的查询类应用， 选择一个非事务型的存储引擎，可以活得更高的性能。

#### 事务的隔离级别

1. read uncommitted (未提交读)

   事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取位提交的数据，这也被称为__脏读（Dirty Read）__ 。在实际应用中一般很少使用

2. read committed ( 提交读 )

   __大多数数据系统的默认隔离级别都是这个级别（但是MySQL不是）__。read committed 满足： 一个事务从开始直到提交之前，所做的任何修改对其他事务不可见的，这个级别有时候也叫做不可重复读，因为两次执行同样的查询，可能会得倒不一样的结果

3. repeatable read （可重复读）

   REPEATABLE READ 解决了脏读的问题， 该级别保证了在同一个事务中多次读取同样记录的结果是一致的。但是理论上，可重复读隔离级别还是无法解决另外一个幻读（Phantom Read）的问题。__所谓幻读__ 指得是当某个事物在读取某个范围内的记录时， 会产生幻行（Phantom Row）。InnoDB存储引擎解决了幻读的问题

4. serializable （可串行化）

   SERIALIZABLE 是最高的隔离级别。它通过强制事务串行执行，避免了前面说的幻读的问题。简单的说，SERIALIZABLE会在读取的每一行数据上都加锁， 所以可能导致大量的超时和锁争用的问题。实际应用中也很少用到这个隔离级别

   | 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
   | ---------------- | ---------- | ---------------- | ---------- | ------ |
   | READ UNCOMMITTED | yes        | yes              | yes        | no     |
   | READ COMMITTED   | no         | yes              | yes        | no     |
   | REPEATABLE READ  | no         | no               | yes        | no     |
   | SERIALIZABLE     | no         | no               | no         | yes    |

   

