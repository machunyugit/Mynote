#### 对文章进行投票功能

1. 数据库表的设计

   * 使用两个有序集合记录文章

     第一个__有序集合__ 的成员为文章ID, 分值为文章发布时间,  网站就可以实现按照文章发布时间的先后顺序来展示文章ID. 

     第二个__有序集合__ 的成员同样为文章ID, 而分值则为文章的评分,    这样网站可以根据评分的高低来展示文章

   * 为了防止用户对同一篇文章进行多次投票, 网站需要为每篇文章记录一个已投票用户名单

     __为每篇文章创建一个集合__ 

     ```html
     sadd 尝试将用户添加到记录文章已投票用户名单的集合中, 如果成功则表明是第一次投票, 如果不成功,这表
     	明已经投过票
     zadd article 90 tom   用来添加
     zscore article  tom   用来检查对应的文章的排序字段
     zincrby (命令用于对有序集合成员的分值执行自增)
     hincrby (对散列记录的文章投票数量进行更新)
     ```

2. 发布并获取文章

   * 使用计数器

     ```html
     incr 命令生成一个键名
     sadd 将文章发布者的id添加到记录文章已投票用户名单的集合里面
     expire 命令为这个集合设置一个有效期, 一周之后自动删除
     zadd   将文章发布时间和初始评分信息存储到有序集合中
     zrevrange 获取多个id,从大到小
     ```

3. 对文章进行分组

   * 使用集合来记录群组都包含了那些文章id
   * 对存储群组文章的集合和存储文章评分的有序集合执行`zinterstore`,程序可以得到按照文章评分排序的群组文章
   * 对存储群组文章的集合和存储文章时间的有序集合执行`zinterstore` ,程序可以得到按照时间排序的群组文章

4. 数据行的缓存(为了应对促销活动带来的大量负载)

   * 具体的数据储存设计

     * 编写一个持续运行的守护进程函数, 让这个函数将指定的数据行缓存到redis里面
     * 将数据行编码为json字典并存储在redis的字符串里面, 其中, 数据列的名字被映射为json字典的键, 而数据行的值则会被映射为json字典的值
     * 使用两个有序集合来记录应该在何时对缓存进行更新, 第一个有序集合为调度有序集合, 它的成员为数据行的行ID, 而分值则是一个时间戳, 这个时间戳记录了应该在合适将指定的数据行缓存到redis里面, 第二个有序集合为延时有序集合, 它的成员也是数据行的行ID, 而分值则记录了指定数据行的缓存需要每隔多少秒更新一次

   * 实现方法

     * 将行ID和给定的延迟值添加到延迟有序集合里面, 
     * 将行ID和当前时间的时间戳添加到调度有序集合里面
     * 执行缓存操作的函数需要用到数据行的延迟值, 如果某个数据行的延迟值不存在, 那么程序将取消对这个数据行的调度
     * 如果想移除某个数据行已有的缓存, 并且让缓存函数不再缓存那个数据行,那么只需要把那个数据行的延迟值设置为小于或者等于0就可以了

   * 运行思路

     负责数据行缓存的函数会尝试读取调度有序集合的第一个元素以及该元素的分值, 如果调度有序集合没有包含任何元素, 或者分值存储的时间戳所指定的时间尚未来临, 那么函数会先休眠50毫秒, 然后再重新进行检查. 当缓存函数发现一个需要立即进行更新的数据行时. 缓存函数会检查这个数据行的延迟值: 如果数据行的延迟值小于或者等于0, 那么缓存函数会从缓存有序集合和调度有序啊集合里面移除这个数据行的ID, 并从缓存里面删除这个数据行已有的缓存, 然后再重新进行检查; 对于延迟值大于0的数据行来说, 缓存函数会从数据库里面取出这些行, 将它们编码为json格式并存储到redis里面, 然后更新这些行的调度时间

5. Redis的性能测试程序

   ```html
   redis-benchmark [-h <host>] [-p <port>] [-c <clients>] [-n <requests]> [-k <boolean>]
     
    -h <hostname>      Server hostname (default 127.0.0.1)
    -p <port>          Server port (default 6379)
    -s <socket>        Server socket (overrides host and port)
    -a <password>      Password for Redis Auth
    -c <clients>       Number of parallel connections (default 50)
    -n <requests>      Total number of requests (default 100000)
    -d <size>          Data size of SET/GET value in bytes (default 2)
   ```

6. 自动补全最近联系人实现思路

   > 构建最近联系人自动补全列表通常需要对Redis执行3个操作
   >
   > 1. 添加或者更新一个联系人, 让他成为最新的被联系用户, 这个操作包含下面3个步骤
   >    * 如果指定的联系人已经存在于最近联系人列表里面, 那么从列表里面移除他
   >    * 将指定的联系人添加到最近联系人列表的最前面
   >    * 如果在添加操作完成之后, 最近联系人列表包含的联系人数量超过了100个, 那么对列表进行修剪,只保留位于列表前面的100联系人. 