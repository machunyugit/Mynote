## 命名

```go
/**
  关键字
    break        default       func       interface       select
    case         defer         go         map             struct
    chan         else          goto       package         switch
    const        fallthrough   if         range           type
    continue     for           import     return          var
*/
/**
	内建常量
	 		true 	false		iota   null

	内建类型
	 		int 	int8	int16	int32	int64
	 		uint	uint8	uint16	uint32	uint64
	 		float32	float64
	 		bool byte	rune 	string error

	内建函数
	 		make	len		cap		append		copy	close	delete
	 		complex	real 	imag	panic 		recover

	 		make	len		cap		append 		copy	close	delete
	 		real	panic	recover
*/
```

## 变量

```go
// 声明
  var intA int = 9
  var stringA string = "abc"
  var floatA float32 = 9.87
	// 批量声明
	var i, j, k int

// 简短变量声明,简短变量声明被广泛用于大部分的局部变量的声明和初始化。
	intC := 9
	stringC := 10
	//批量初始化
	i, j := 0, 1

//指针
// 任何类型的零值都是 nil
// 指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。
    var x, y *int
    fmt.Println(x,y)
    fmt.Println(x == x, x == y, x == nil) //true true true

    var x_t, y_t int
    fmt.Println(&x_t == &x_t, &x_t == &y_t, &x_t == nil) // true false false
```

## 赋值

```go
	var x int = 1

  v := 1
  v++    // 等价方式 v = v + 1；v 变成 2
  v--    // 等价方式 v = v - 1；v 变成 1

//元组赋值
	x, y = y, x

//隐式的赋值行为
	medals := []string{"gold", "silver", "bronze"}
```

## 类型

### 声明类型

```go
type Duration int64
```

## 包和文件

1. 一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的。即可以在外部使用的。

## 数组

数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。

```go
// 声明
	var q [3]int = [3]int{1,2,3}
// 如果在数组的长度位置出现的是 ... 省略号，则表示数组的长度是根据初始化值的个数来计算。
	q := [...]int{1,2,3}
```

## slice

```go
//声明
	var s1 []int

// 简短声明
	s2 := []imt{0,1,2,3,4,5}

// make 创建一个指定元素类型、长度和容量的slice，容量部分可以省略。
// 在底层，make 创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。
  s3 = make([]int,3)
  s4 = make([]int,3,4)

//slice 唯一合法的比较
if summer == nil {}


//append 函数，内置函数用于向 slice 函数追加元素
s1 := append(s2,6,7,8)
```

## map

```go
//声明
	ages := make(map[string]int)
	ages :=map[string]int

  ages := map[string]int{
    "alice":31,
    "charlie":34,
  }
 
	ages := make(map[string]int)
	ages["alice"] = 31
	ages["charlie"] = 34

//删除元素
	delete(ages,"alice")

//禁止对map元素取址的原因是 map 可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。

//map 类型的零值为 nil
```

**Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。下面是常见的处理方式：**

```go
package main

import (
	"fmt"
	"sort"
)

func main(){
	ages := map[string]int{
		"alice":20,
		"charlie":34,
	}
  //预先分配指定容量
	names := make([]string, 0, len(ages))
	for name := range ages {
		names = append(names,name)
	}
	sort.Strings(names)
	for _, name := range names {
		fmt.Printf("%s\t%d\n", name, ages[name])
	}
}
```

## 结构体

```go
//声明
  type tree struct {
    value       int
    left, right *tree
  }
```

## 函数

```go
//声明
func name(parameter-list) (result-list){
  
}

//遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名
package math
func Sin(x float64) float


//匿名函数
func squares() func() int{
  var x int 
  return func() int {
    x++
    return x * x
  }
}

//可变参数
func sum(vals ...int) int{
  total := 0
  for _,val := range vals {
    total += val
  }
  return total
}
fmt.Println(sum(1, 2, 3, 4))
```

### defer 函数

1. defer 的执行顺序与声明顺序相反，越后面的defer函数越先被执行。
2. 当执行到（defer）该语句时，函数和参数表达式得到计算，但直到包含该 defer 语句的函数执行完毕时，defer 后的函数才会被执行，不论包含 defer 语句的函数是通过 return 正常结束，还是由于 panic 导致的异常结束。

```go
//eg.1
  func main() {
      defer fmt.Println(1)
      defer fmt.Println(2)
      defer fmt.Println(3)
      defer fmt.Println(4)
  }
	//result 4 3 2 1

//eg.2
  func f()(r int){
    defer func(r int){
      r = r + 5
    }(r)
    return 1
  }
	// result 1

//eg.3
  func f()(result int){
    defer func(){
      result ++
    }()
    return 0
  }
	//result 1

//eg.4
  func f()(r int) {
    t :=5
    defer func(){
      t = t + 5
    }()
    return t
  }
	//result 5
```

### [panic 和 recover](https://blog.go-zh.org/defer-panic-and-recover)

1. panic 是一个内置函数，它用来停止正常的流程并使程序处于 panicking 状态。当函数F调用 panic 时，F 函数立即停止执行，然后运行在 F 中定义的所有 defer 函数并返回调用者，对于调用者来说，F 函数的行为就像 panic 一样。该进程继续向上执行，直到当前 goroutine 中的所有函数都返回，此时程序奔溃。
2. Recover 是一个内置函数，可重新控制 panicking 状态下的 goroutine。Recover只在延迟函数（defer）内部有用。在正常执行期间，调用 recover 将返回nil，并且没有其他效果。如果当前 goroutine处于 panicking，调用 recover 将捕获指定给 panic 的值并恢复正常执行。

```go
package main

import "fmt"

func main(){
	f()
	fmt.Println("Returned normally from f.")
}

func f(){
	defer func(){
		if r := recover(); r != nil {
			fmt.Println("Recovered in f",r)
		}
	}()
	fmt.Println("calling g.")
	g(0)
	fmt.Println("Returned normally from g.")
}

func g(i int){
	if i > 3 {
		fmt.Println("panicking!")
		panic(fmt.Sprintf("%v",i))
	}
	defer fmt.Println("defer in g",i)
	fmt.Println("printing in g",i)
	g(i+1)
}

/*
  calling g.
  printing in g 0
  printing in g 1
  printing in g 2
  printing in g 3
  panicking!
  defer in g 3
  defer in g 2
  defer in g 1
  defer in g 0
  Recovered in f 4
  Returned normally from f
*/
```

## 方法

1. 在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。
2. 在Go语言里，可以给 string、slice、map定义方法。

```go
// struct 类型
  type Point struct {
    X, Y float64
  }

  func (p Point) Distance(q Point) float64 {
    return math.Hypot(q.X-p.X, q.Y-p.Y)
  }

//slice 
  // A Path is a journey connecting the points with straight lines.
  type Path []Point
  // Distance returns the distance traveled along the path.
  func (path Path) Distance() float64 {
      sum := 0.0
      for i := range path {
          if i > 0 {
              sum += path[i-1].Distance(path[i])
          }
      }
      return sum
  }

//string
  package main
  import (
    "fmt"
  )
  type str_test string
  func main() {
    var test str_test = "hello "
    fmt.Println(test.strJoin("world")) //hello world
  }
  func (dist str_test) strJoin(srcd str_test) string {
    return string(dist + srcd)
  }
```